
.. _program_listing_file__home_runner_work_rko_lio_rko_lio_rko_lio_core_lio.hpp:

Program Listing for File lio.hpp
================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_rko_lio_rko_lio_rko_lio_core_lio.hpp>` (``/home/runner/work/rko_lio/rko_lio/rko_lio/core/lio.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * MIT License
    *
    * Copyright (c) 2025 Meher V.R. Malladi.
    *
    * Permission is hereby granted, free of charge, to any person obtaining a copy
    * of this software and associated documentation files (the "Software"), to deal
    * in the Software without restriction, including without limitation the rights
    * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    * copies of the Software, and to permit persons to whom the Software is
    * furnished to do so, subject to the following conditions:
    *
    * The above copyright notice and this permission notice shall be included in all
    * copies or substantial portions of the Software.
    *
    * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    * SOFTWARE.
    */
   
   #pragma once
   #include "sparse_voxel_grid.hpp"
   #include "util.hpp"
   #include <optional>
   
   namespace rko_lio::core {
   class LIO {
   public:
     struct Config {
       bool deskew = true;
   
       size_t max_iterations = 100;
   
       double voxel_size = 1.0;
   
       int max_points_per_voxel = 20;
   
       double max_range = 100.0;
   
       double min_range = 1.0;
   
       double convergence_criterion = 1e-5;
   
       double max_correspondance_distance = 0.5;
   
       int max_num_threads = 0;
   
       bool initialization_phase = false;
   
       double max_expected_jerk = 3;
   
       bool double_downsample = true;
   
       double min_beta = 200;
     };
   
     Config config;
   
     SparseVoxelGrid map;
   
     State lidar_state;
   
     ImuBias imu_bias;
   
     Eigen::Vector3d mean_body_acceleration = Eigen::Vector3d::Zero();
   
     Eigen::Matrix3d body_acceleration_covariance = Eigen::Matrix3d::Identity();
   
     IntervalStats interval_stats;
   
     explicit LIO(const Config& config_)
         : config(config_), map(config_.voxel_size, config_.max_range, config_.max_points_per_voxel) {}
   
     void add_imu_measurement(const ImuControl& base_imu);
   
     void add_imu_measurement(const Sophus::SE3d& extrinsic_imu2base, const ImuControl& raw_imu);
   
     Vector3dVector register_scan(const Vector3dVector& scan, const TimestampVector& timestamps);
   
     Vector3dVector register_scan(const Sophus::SE3d& extrinsic_lidar2base,
                                  const Vector3dVector& scan,
                                  const TimestampVector& timestamps);
   
     std::vector<std::pair<Secondsd, Sophus::SE3d>> poses_with_timestamps;
   
   private:
     void initialize(const Secondsd lidar_time);
   
     std::optional<AccelInfo> get_accel_info(const Sophus::SO3d& rotation_estimate, const Secondsd& time);
   
     bool _initialized = false;
   
     Sophus::SO3d _imu_local_rotation;
   
     Secondsd _imu_local_rotation_time = Secondsd{0.0};
   
     Secondsd _last_real_imu_time = Secondsd{0.0};
   
     Eigen::Vector3d _last_real_base_imu_ang_vel = Eigen::Vector3d::Zero();
   };
   } // namespace rko_lio::core
